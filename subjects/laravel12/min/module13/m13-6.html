<!DOCTYPE html>
<html lang="nl" data-theme="light" data-color="red">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP Testing</title>

    <script src="../../../../assets/js/theme-init.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="../../../../assets/css/style.css">
</head>
<body>

<div data-include="../../../../components/header.html"></div>

<div class="layout-wrapper">
    <div data-include="../../../../components/sidebar.html"></div>

    <main class="main-content">
        <h1>HTTP Testing</h1>
        <p>Wanneer je applicatie communiceert met externe API's (zoals Mollie, een weer-API of OpenAI), wil je deze communicatie testen. Echter, je wilt in je tests <strong>niet</strong> daadwerkelijk verbinding maken met deze externe servers. Dit is traag, onbetrouwbaar (als de API down is) en kan geld kosten.</p>

        <h2>Leeruitkomsten</h2>
        <ul style="margin-bottom: 2rem;">
            <li>Ik weet waarom we externe API calls mocken tijdens testen.</li>
            <li>Ik kan `Http::fake()` gebruiken om neppe responses terug te geven.</li>
            <li>Ik kan controleren of mijn applicatie de juiste data verstuurt.</li>
        </ul>

        <h3>Http Faking</h3>
        <p>Laravel's <code>Http</code> facade heeft een geweldige <code>fake()</code> methode. Hiermee vertel je Laravel: "Als er een request wordt gedaan, doe het niet echt, maar geef dit antwoord terug."</p>

        <div class="note-box">Bestand: <code>tests/Feature/WeatherTest.php</code></div>
        <pre><code class="language-php">
use Illuminate\Support\Facades\Http;

test('it retrieves weather for a city', function () {
    // 1. Arrange: Fake de API response
    Http::fake([
        // Voor elk request naar api.weather.com...
        'api.weather.com/*' => Http::response([
            'temp' => 25,
            'condition' => 'Sunny'
        ], 200)
    ]);

    // 2. Act: Roep je eigen service aan (die intern Http::get doet)
    $response = $this->get('/weather/rotterdam');

    // 3. Assert: Je applicatie denkt dat het 25 graden is
    $response->assertSee('25 graden');
    $response->assertSee('Sunny');
});
        </code></pre>

        <h3>Controleren van Uitgaande Data</h3>
        <p>Soms wil je controleren of je applicatie de juiste data <em>verstuurt</em> naar de externe partij (bijvoorbeeld: wordt de API key wel meegestuurd?).</p>

        <pre><code class="language-php">
use Illuminate\Http\Client\Request;

test('it sends correct data to weather api', function () {
    Http::fake();

    $this->get('/weather/rotterdam');

    // Assert dat er een request is gedaan naar de specifieke URL
    Http::assertSent(function (Request $request) {
        return $request->url() == 'https://api.weather.com/v1/forecast' &&
               $request['city'] == 'rotterdam' &&
               $request['apikey'] == 'secret-key';
    });
});
        </code></pre>
    </main>

    <aside class="sidebar-right">
        <div class="toc-container">
            <h4>Inhoud</h4>
            <ul id="toc-list" class="toc-list">
            </ul>
        </div>
    </aside>
</div>

<div data-include="../../../../components/footer.html"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="../../../../assets/js/script.js"></script>
</body>
</html>