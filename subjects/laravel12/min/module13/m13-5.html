<!DOCTYPE html>
<html lang="nl" data-theme="light" data-color="red">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testen met de Database</title>

    <script src="../../../../assets/js/theme-init.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="../../../../assets/css/style.css">
</head>
<body>

<div data-include="../../../../components/header.html"></div>

<div class="layout-wrapper">
    <div data-include="../../../../components/sidebar.html"></div>

    <main class="main-content">
        <h1>Testen met de Database</h1>
        <p>Bijna elke Feature test heeft een database nodig. Als je een gebruiker aanmaakt in een test, wordt deze echt opgeslagen. Dit levert twee grote problemen op:</p>
        <ol>
            <li><strong>Vervuiling:</strong> Je test-database raakt vol met onzin-data ("test1", "asdasd").</li>
            <li><strong>State:</strong> Als test A een gebruiker verwijdert, faalt test B misschien omdat die gebruiker er niet meer is.</li>
        </ol>
        <p>Elke test moet beginnen met een schone lei. Laravel heeft hiervoor twee traits.</p>

        <h2>Leeruitkomsten</h2>
        <ul style="margin-bottom: 2rem;">
            <li>Ik weet hoe ik de database schoon houd met de `RefreshDatabase` trait.</li>
            <li>Ik kan data seeden voor specifieke tests.</li>
            <li>Ik kan controleren of data correct is opgeslagen met `assertDatabaseHas`.</li>
        </ul>

        <h3>1. RefreshDatabase (De Standaard)</h3>
        <p>De <code>RefreshDatabase</code> trait is de moderne, snelle manier.
            <br><strong>Hoe werkt het?</strong> Het gebruikt database <em>transacties</em>. Voor elke test start een transactie. Alles wat je doet (users aanmaken, posts verwijderen) gebeurt binnen die transactie. Na de test voert Laravel een <code>ROLLBACK</code> uit.
            <br><strong>Resultaat:</strong> Er is nooit daadwerkelijk iets naar de harde schijf geschreven. De database is na de test exact zoals hij ervoor was. Dit is razendsnel.</p>

        <div class="note-box">Bestand: <code>tests/Pest.php</code> (of in je testfile)</div>
        <pre><code class="language-php">
use Illuminate\Foundation\Testing\RefreshDatabase;

// Activeer de trait voor alle Feature tests
uses(RefreshDatabase::class)->in('Feature');
        </code></pre>

        <h3>2. DatabaseMigrations (De Oude Manier)</h3>
        <p>Vroeger gebruikten we <code>DatabaseMigrations</code>.
            <br><strong>Hoe werkt het?</strong> Voor <em>elke</em> test worden alle tabellen uit de database gegooid (DROP) en worden alle migraties opnieuw gedraaid (MIGRATE).
            <br><strong>Resultaat:</strong> Dit is extreem traag, vooral als je veel tabellen hebt. Gebruik dit alleen als transacties niet werken (bijv. sommige MySQL fulltext features).</p>

        <h3>Seeding: Data Klaarzetten</h3>
        <p>Soms heb je basisdata nodig die in <em>elke</em> test aanwezig moet zijn, bijvoorbeeld een lijst met Rollen en Permissies. Je wilt dit niet in elke testfunctie opnieuw aanmaken.
            <br>Hiervoor gebruiken we de <code>beforeEach</code> functie in Pest (of <code>setUp</code> in PHPUnit).</p>

        <div class="note-box">Bestand: <code>tests/Feature/AdminTest.php</code></div>
        <pre><code class="language-php">
use Database\Seeders\RoleSeeder;

beforeEach(function () {
    // Deze code draait VOOR elke test in dit bestand.
    // De database is hier leeg (door RefreshDatabase).

    // We draaien de seeder om rollen aan te maken
    $this->seed(RoleSeeder::class);
});

test('admin can access dashboard', function () {
    // We kunnen nu direct een user met een rol maken,
    // omdat de rollen bestaan.
    $user = User::factory()->create();
    $user->assignRole('admin');

    $this->actingAs($user)
         ->get('/admin')
         ->assertStatus(200);
});
        </code></pre>

        <h3>Asserts: Controleren in de Database</h3>
        <p>Vaak wil je niet alleen weten of de pagina laadt, maar ook of de data correct is opgeslagen. Gebruik hiervoor <code>assertDatabaseHas</code>.</p>

        <pre><code class="language-php">
test('new project is stored in database', function () {
    $data = [
        'title' => 'Nieuw Project',
        'description' => 'Test omschrijving'
    ];

    // Act: Doe de POST request
    $this->post('/projects', $data);

    // Assert: Check of er een record is in de tabel 'projects'
    // die matcht met deze data
    $this->assertDatabaseHas('projects', [
        'title' => 'Nieuw Project',
        // We checken de omschrijving niet, puur als voorbeeld
    ]);

    // Of check dat iets er NIET is:
    // $this->assertDatabaseMissing('projects', ['title' => 'Oud Project']);
});
        </code></pre>
    </main>

    <aside class="sidebar-right">
        <div class="toc-container">
            <h4>Inhoud</h4>
            <ul id="toc-list" class="toc-list">
            </ul>
        </div>
    </aside>
</div>

<div data-include="../../../../components/footer.html"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="../../../../assets/js/script.js"></script>
</body>
</html>