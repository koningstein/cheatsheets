<!DOCTYPE html>
<html lang="nl" data-theme="light" data-color="red">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Casts & Accessors</title>

    <script src="../../../../assets/js/theme-init.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="../../../../assets/css/style.css">
</head>
<body>

<div data-include="../../../../components/header.html"></div>

<div class="layout-wrapper">
    <div data-include="../../../../components/sidebar.html"></div>

    <main class="main-content">
        <h1>Casts & Accessors</h1>

        <p>Soms wil je data anders opslaan in de database dan hoe je het in je PHP-code gebruikt. Laravel biedt hiervoor krachtige tools: <strong>Casts</strong> en <strong>Accessors/Mutators</strong>.</p>

        <h2>Leeruitkomsten</h2>
        <ul style="margin-bottom: 2rem;">
            <li>Ik kan attribute casting gebruiken met <code>protected function casts()</code> voor automatische type conversies.</li>
            <li>Ik begrijp wanneer ik casts gebruik (boolean, array, datetime, hashed, encrypted).</li>
            <li>Ik kan accessors en mutators maken met <code>Attribute::make()</code> om data te manipuleren bij ophalen en opslaan.</li>
            <li>Ik kan virtual accessors maken voor berekende attributen die niet in de database bestaan.</li>
        </ul>

        <h3>1. Attribute Casting ($casts)</h3>
        <p>Casting zorgt voor automatische conversie van datatypes. De database kent bijvoorbeeld geen <code>array</code> of <code>boolean</code> (vaak TINYINT), maar PHP wel.</p>

        <h4>Wanneer gebruik je dit?</h4>
        <ul>
            <li><strong>Boolean:</strong> Database geeft <code>0</code> of <code>1</code>, jij wilt <code>false</code> of <code>true</code>.</li>
            <li><strong>Array/JSON:</strong> Je wilt instellingen als een array gebruiken in PHP (<code>['dark_mode' => true]</code>), maar opslaan als JSON-string in de database.</li>
            <li><strong>Datum:</strong> Je wilt datumkolommen automatisch als Carbon-object krijgen (net zoals <code>created_at</code>).</li>
            <li><strong>Encryptie:</strong> Je wilt gevoelige data (zoals een API key) versleuteld opslaan, maar leesbaar terugkrijgen.</li>
        </ul>

        <div class="note-box">Bestand: <code>app/Models/User.php</code></div>
        <pre><code class="language-php">
protected function casts(): array
{
    return [
        // Converteer 1/0 naar true/false
        'is_admin' => 'boolean',

        // Converteer JSON-string uit DB naar PHP Array (en andersom bij opslaan)
        'settings' => 'array',

        // Zorg dat dit veld altijd een Carbon datum object is
        'last_login_at' => 'datetime',

        // Automatisch hashen bij opslaan (handig voor wachtwoorden!)
        'password' => 'hashed',

        // Automatisch encrypten in DB en decrypten bij ophalen
        'secret_key' => 'encrypted',
    ];
}
        </code></pre>

        <h3>2. Accessors & Mutators (Nieuwe Syntax)</h3>
        <p>Soms is een simpele type-conversie niet genoeg en wil je data <strong>manipuleren</strong>.</p>
        <ul>
            <li><strong>Accessor (Get):</strong> Pas de waarde aan als je hem <em>ophaalt</em> (bijv. prijs in centen naar euro's, of naam naar hoofdletters).</li>
            <li><strong>Mutator (Set):</strong> Pas de waarde aan voordat je hem <em>opslaat</em> (bijv. spaties weghalen, of prijs van euro's naar centen).</li>
        </ul>

        <h4>Voorbeeld: Prijs (Cents vs Euro)</h4>
        <p>Het is 'best practice' om geld in de database als integers (centen) op te slaan om afrondingsfouten te voorkomen. Maar in je code wil je met euro's werken.</p>

        <div class="note-box">Bestand: <code>app/Models/Product.php</code></div>
        <pre><code class="language-php">
use Illuminate\Database\Eloquent\Casts\Attribute;

protected function price(): Attribute
{
    return Attribute::make(
        // Accessor (GET): Van Database (centen) naar PHP (euro)
        // 1050 cent -> 10.50
        get: fn (int $value) => $value / 100,

        // Mutator (SET): Van PHP (euro) naar Database (centen)
        // 10.50 -> 1050
        set: fn (float $value) => $value * 100,
    );
}
        </code></pre>

        <h3>3. Virtual Accessors (Extra attributen)</h3>
        <p>Je kunt ook attributen maken die helemaal niet in de database bestaan, maar wel handig zijn. Bijvoorbeeld een volledige naam op basis van voor- en achternaam.</p>

        <div class="note-box">Bestand: <code>app/Models/User.php</code></div>
        <pre><code class="language-php">
// Database heeft 'first_name' en 'last_name', maar geen 'full_name'

protected function fullName(): Attribute
{
    return Attribute::make(
        get: fn (mixed $value, array $attributes) =>
            $attributes['first_name'] . ' ' . $attributes['last_name'],
    );
}

// Gebruik: $user->full_name
        </code></pre>
    </main>

    <aside class="sidebar-right">
        <div class="toc-container">
            <h4>Inhoud</h4>
            <ul id="toc-list" class="toc-list">
            </ul>
        </div>
    </aside>
</div>

<div data-include="../../../../components/footer.html"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="../../../../assets/js/script.js"></script>
</body>
</html>